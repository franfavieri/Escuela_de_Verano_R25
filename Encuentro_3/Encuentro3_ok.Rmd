---
title: "**Manipulaci√≥n, transformaci√≥n y procesamiento de datos**"
subtitle: "**Escuela de Verano de R**"
author: |
  **Francisco Favieri**  
  **Beatriz Soria**
date: "**A√±o 2025**"
output:
  slidy_presentation:
    keep_md: true
  pdf_document:
    keep_tex: true
  html_document:
    toc: true
  ioslides_presentation: default
  beamer_presentation: 
    theme: "Madrid"
editor_options: 
  markdown: 
    wrap: 72
fontsize: 24pt
---

```{r, include=FALSE, warning=FALSE}
#Paquetes para que funcione este coso
library(tidyverse)
library(eph)
```

# Introducci√≥n

En esta clase vamos a repasar algunos conceptos clave sobre el uso de
paquetes en R, centr√°ndonos en el paquete `{tidyverse}`. A lo largo de
la sesi√≥n, abordaremos los siguientes temas:

‚úÖ **Parte 1: ¬øQu√© es un paquete en R?** Veremos c√≥mo funcionan los
paquetes y por qu√© son fundamentales para la programaci√≥n en R.\
‚úÖ **Parte 2: Exploraci√≥n del paquete `{eph}`.** Conoceremos qu√© ofrece
este paquete y c√≥mo facilita el trabajo con los datos de la Encuesta
Permanente de Hogares (EPH).\
‚úÖ **Parte 3: Primeros comandos de exploraci√≥n.** Aprenderemos a
examinar los datos descargados con `{eph}`, incluyendo visualizaci√≥n de
variables y estructuras.\
‚úÖ **Parte 4: Introducci√≥n a `{tidyverse}`.** Empezaremos a trabajar con
uno de los paquetes m√°s importantes para la manipulaci√≥n de datos en R.

La clase tiene una duraci√≥n de **2 horas y 30 minutos**, con **dos
recreos de 15 minutos** para que podamos despejarnos y mover las
piernas.

# Parte 1: ¬øQu√© es un paquete en R?

Un **paquete** en R es una colecci√≥n de funciones, datos y documentaci√≥n
organizados en un formato estructurado que extiende las capacidades de
R.

üìå Los paquetes permiten: - Agregar nuevas funciones a R. - Facilitar la
manipulaci√≥n y visualizaci√≥n de datos. - Automatizar procesos y mejorar
la eficiencia en el an√°lisis.

Los paquetes est√°n disponibles en diferentes fuentes: - **CRAN**
(Comprehensive R Archive Network) es el repositorio oficial de paquetes
de R. Es una red de servidores donde se almacenan, verifican y
distribuyen los paquetes de R.

üîπ M√°s informaci√≥n:\
üìå Sitio oficial de CRAN: <https://cran.r-project.org>

-   **GitHub**: es una plataforma de desarrollo colaborativo donde los
    programadores pueden compartir c√≥digo. En el caso de R, permite
    descargar paquetes en desarrollo que a√∫n no han sido subidos a CRAN.

-   **Paquetes locales**: Paquetes creados y almacenados en tu
    computadora.

# Instalaci√≥n y carga de paquetes en R

Para instalar un paquete desde CRAN, usamos:

```{r 1, include=FALSE}
# Configurar CRAN correctamente para evitar errores en knitr
options(repos = c(CRAN = "https://cloud.r-project.org"))
```

```{r 2 , message=FALSE, warning=FALSE}
install.packages("eph")  # Instala el paquete eph
```

Para instalar un paquete desde GitHub:

```{r 3, message=FALSE, warning=FALSE}
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
library(devtools)
install_github("tidyverse/ggplot2")  # Instala ggplot2 desde GitHub
```

Para cargar un paquete ya instalado:

```{r 4, message=FALSE, warning=FALSE}
library(tidyverse)  # Carga ggplot2 en la sesi√≥n de R
```

Para ver los paquetes instalados en tu sistema:

```{r 5}
installed.packages()[,1]  # Muestra una lista de paquetes instalados
```

# Parte 2: ¬øQu√© es el paquete `{eph}`?

El paquete `{eph}` es una herramienta en R dise√±ada para facilitar el
acceso y manipulaci√≥n de los microdatos de la **Encuesta Permanente de
Hogares (EPH)** del **INDEC** en Argentina. Permite descargar las bases
de datos directamente desde la web del INDEC sin necesidad de bajarlas
manualmente, y simplifica su an√°lisis dentro del entorno de R.

**M√°s informaci√≥n y documentaci√≥n oficial:** [CRAN -
eph](https://cran.r-project.org/web/packages/eph/eph.pdf)

## Instalaci√≥n y carga de `{eph}`

``` r
install.packages("eph")  # Instala el paquete eph
library(eph)  # Carga el paquete eph
```

## Funciones principales de `{eph}`

El paquete cuenta con varias funciones clave. Aqu√≠ est√°n las m√°s
importantes:

| **Funci√≥n**           | **¬øQu√© hace?**                                          |
|-------------------------------------------|-----------------------------|
| `get_microdata()`     | Descarga datos de la EPH directamente desde el INDEC.   |
| `organize_labels()`   | Reemplaza c√≥digos num√©ricos por etiquetas descriptivas. |
| `categorize_area()`   | Clasifica regiones geogr√°ficas dentro de la EPH.        |
| `calculate_poverty()` | Calcula tasas de pobreza e indigencia.                  |

# Ejemplo de uso: Descargar datos de la EPH

Si queremos obtener los datos individuales del **4to trimestre de
2023**, usamos:

```{r 6}
library(eph)  # Asegurar que el paquete est√° cargado

eph_data <- get_microdata(year = 2023, trimester = 4, type = "individual")

# Ver primeras filas de la base
dim(eph_data)
head(eph_data)
```

Para ver qu√© variables tiene la base:

```{r 7}
colnames(eph_data)  # Nombres de las variables
str(eph_data)       # Estructura de la base
```

# Aplicando `organize_labels()` para etiquetas descriptivas

Los datos descargados contienen variables con c√≥digos num√©ricos
dif√≠ciles de interpretar. Para hacerlos m√°s legibles, utilizamos
`organize_labels()`:

```{r 8}
# Convertir c√≥digos num√©ricos en etiquetas descriptivas
eph_data_labeled <- organize_labels(eph_data)

# Comparar antes y despu√©s
head(eph_data[c("CH04", "ESTADO", "CAT_OCUP")])  # Antes de aplicar organize_labels()
head(eph_data_labeled[c("CH04", "ESTADO", "CAT_OCUP")])  # Despu√©s de aplicar organize_labels()
```

## Explicaci√≥n:

-   `CH04`: Representa el sexo del encuestado (antes: `1, 2`, despu√©s:
    `"Var√≥n"`, `"Mujer"`).
-   `ESTADO`: Estado de actividad laboral (antes: `1, 2, 3`, despu√©s:
    `"Ocupado"`, `"Desocupado"`, `"Inactivo"`).
-   `CAT_OCUP`: Categor√≠a ocupacional (antes: `1, 2, 3, 4`, despu√©s:
    `"Patr√≥n"`, `"Cuenta Propia"`, `"Asalariado"`,
    `"Trabajador Familiar"`).

## Para obtener un resumen de las etiquetas aplicadas:

```{r 9}
summary(eph_data_labeled)
```

**Beneficio:** Facilita la interpretaci√≥n de los datos sin necesidad de
consultar los c√≥digos num√©ricos en el manual del INDEC.

# **Ejemplo de uso: Descargar datos de hogares de la EPH**

Si queremos obtener los datos de hogares del **4to trimestre de 2023**,
usamos:

```{r 10}
library(eph)  # Asegurar que el paquete est√° cargado

eph_data_hogar <- get_microdata(year = 2023, trimester = 4, type = "hogar")

# Ver primeras filas de la base
dim(eph_data_hogar)
head(eph_data_hogar)
```

## Tipos de bases disponibles en `{eph}`

Cuando us√°s `get_microdata()`, pod√©s elegir entre diferentes tipos de
bases de datos:

| **Tipo de base** | **Descripci√≥n**                       |
|------------------|---------------------------------------|
| "individual"     | Datos de cada persona encuestada.     |
| "hogar"          | Informaci√≥n de cada hogar encuestado. |
| "vivienda"       | Datos de las viviendas encuestadas.   |

# Parte 3: ¬øQu√© es el paquete `{tidyverse}`?

El paquete `{tidyverse}` es una colecci√≥n de paquetes en R dise√±ada para
facilitar el procesamiento, manipulaci√≥n, y visualizaci√≥n de datos de
manera eficiente y legible. Fue creado por Hadley Wickham y su equipo en
RStudio, y agrupa una serie de paquetes que comparten una filosof√≠a
basada en:

-   **Sintaxis coherente y funcional**\
-   **Principios de "tidy data"** (datos organizados en un formato
    estructurado)\
-   **Uso de la tuber√≠a (`%>%`)** para encadenar funciones de manera
    clara\
-   **El tidyverse facilita el an√°lisis de datos**, eliminando c√≥digo
    redundante y promoviendo un flujo de trabajo intuitivo para quienes
    trabajan con ciencias sociales computacionales.

**M√°s informaci√≥n y documentaci√≥n oficial:** [Tidyverse - R for Data
Science](https://www.tidyverse.org/)

## Instalaci√≥n y carga de `{tidyverse}`

```{r 11, message=FALSE, warning=FALSE}
install.packages("tidyverse")  # Instala el paquete tidyverse
library(tidyverse)  # Carga todos los paquetes del tidyverse
```

# Paquetes incluidos en `{tidyverse}`

Si ustedes instalan tidyverse entonces no tienen que estar instalando
todos estos paquetes uno por uno.

| **Paquete**   | **Funcionalidad principal**            | **Funciones clave**                                                          |
|------------------|--------------------------|-----------------------------|
| **dplyr**     | Manipulaci√≥n y transformaci√≥n de datos | `filter()`, `select()`, `mutate()`, `group_by()`, `summarise()`, `arrange()` |
| **tidyr**     | Organizaci√≥n y estructuraci√≥n de datos | `pivot_longer()`, `pivot_wider()`, `separate()`, `unite()`                   |
| **readr**     | Importaci√≥n de archivos                | `read_csv()`, `read_delim()`, `write_csv()`                                  |
| **purrr**     | Programaci√≥n funcional y listas        | `map()`, `map_df()`, `map_chr()`                                             |
| **tibble**    | Tablas mejoradas en R                  | `as_tibble()`, `tibble()`                                                    |
| **stringr**   | Manipulaci√≥n de texto y caracteres     | `str_detect()`, `str_replace()`, `str_to_lower()`                            |
| **forcats**   | Manejo avanzado de factores            | `fct_reorder()`, `fct_lump()`, `fct_relevel()`                               |
| **lubridate** | Manipulaci√≥n de fechas y tiempos       | `ymd()`, `mdy()`, `hms()`, `floor_date()`                                    |

En este taller, utilizaremos tidyverse en combinaci√≥n con el paquete eph
para analizar bases de la Encuesta Permanente de Hogares (EPH), lo que
nos permitir√° realizar transformaciones, c√°lculos y res√∫menes sobre
variables clave del mercado de trabajo.

# `dplyr`: Manipulaci√≥n de datos en R

El paquete **dplyr** de **tidyverse** es una herramienta fundamental
para la manipulaci√≥n eficiente de datos en R. Permite realizar
operaciones como filtrado, selecci√≥n, transformaci√≥n, agrupaci√≥n y
resumen de datos de manera intuitiva.

En este documento, aplicamos todas sus funciones clave sobre la
**Encuesta Permanente de Hogares (EPH)** utilizando el paquete `eph`.

```{r 12, include=FALSE}
# Instalar paquetes si es necesario
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
if (!requireNamespace("eph", quietly = TRUE)) install.packages("eph")

# Cargar paquetes
library(tidyverse)
library(eph)
```

## Cargar base de datos

```{r 13}
# Obtener datos de la EPH (trimestre 3 de 2023)
eph_data <- get_microdata(year = 2023, trimester = 3, type = "individual")
head(eph_data)
```

# Funciones clave de `dplyr`

-   üîç **`filter()`** ‚Üí Filtra filas seg√∫n condiciones espec√≠ficas.
    -   Ejemplo: `filter(data, edad > 30)`
-   üìë **`select()`** ‚Üí Selecciona columnas espec√≠ficas de un dataframe.
    -   Ejemplo: `select(data, nombre, salario)`
-   ‚úèÔ∏è **`mutate()`** ‚Üí Crea o modifica columnas dentro del dataframe.
    -   Ejemplo: `mutate(data, salario_anual = salario * 12)`
-   üìä **`group_by()`** ‚Üí Agrupa datos seg√∫n una o varias variables.
    -   Ejemplo: `group_by(data, departamento)`
-   üßÆ **`summarise()`** ‚Üí Resume los datos, calculando estad√≠sticas por
    grupo.
    -   Ejemplo:
        `summarise(data, salario_promedio = mean(salario, na.rm = TRUE))`
-   üîº **`arrange()`** ‚Üí Ordena los datos en orden ascendente o
    descendente.
    -   Ejemplo: `arrange(data, desc(salario))`
-   üî¢ **`count()`** ‚Üí Cuenta la cantidad de observaciones por grupo.
    -   Ejemplo: `count(data, departamento)`
-   üè∑Ô∏è **`rename()`** ‚Üí Cambia el nombre de una columna.
    -   Ejemplo: `rename(data, sueldo = salario)`
-   üöÆ **`distinct()`** ‚Üí Elimina duplicados y devuelve solo valores
    √∫nicos.
    -   Ejemplo: `distinct(data, nombre)`
-   üéØ **`slice()`** ‚Üí Selecciona filas espec√≠ficas seg√∫n su posici√≥n.
    -   Ejemplo: `slice(data, 1:10)`
-   üì• **`pull()`** ‚Üí Extrae una sola columna en forma de vector.
    -   Ejemplo: `pull(data, nombre)`
-   üîÄ **`relocate()`** ‚Üí Cambia el orden de las columnas dentro del
    dataframe.
    -   Ejemplo: `relocate(data, salario, .before = nombre)`
-   üöß **`transmute()`** ‚Üí Crea nuevas columnas pero elimina las
    originales.
    -   Ejemplo: `transmute(data, salario_anual = salario * 12)`
-   üìä **`ggplot2()`** ‚Üí Grafica toda la movida (lo veremos en otra
    clase)
    -   Ejemplo ggplot(data, aes(x = edad, y = salario)) + geom_point())

# **`filter()`**: Filtrar filas en un dataframe

La funci√≥n **`filter()`** en `dplyr` se usa para **seleccionar filas**
de un dataframe que cumplen con una o varias condiciones. Es
especialmente √∫til en el an√°lisis de datos de la **Encuesta Permanente
de Hogares (EPH)**.

## **Caracter√≠sticas clave**

-   Permite aplicar **condiciones l√≥gicas** (`>`, `<`, `==`, `!=`, `>=`,
    `<=`).
-   Se pueden combinar **m√∫ltiples condiciones** con `&` (AND) o `|`
    (OR).
-   Filtra filas **sin modificar las columnas existentes**.
-   Compatible con **`group_by()`** para aplicar filtros dentro de
    grupos. (esto es dios)

### **Ejemplos pr√°cticos con el paquete `EPH`**

# **Ejemplo 1: Filtrar personas mayores de 30**

```{r filter1}
#Gran San Juan
eph_gsj_ocupados <- eph_data %>%
  filter(AGLOMERADO == 27, ESTADO == 1, CH06 >= 25, CH06 <= 50)
dim(eph_gsj_ocupados)

#Gran Mendoza
eph_gmza_ocupados <- eph_data %>%
  filter(AGLOMERADO == 10, ESTADO == 1, CH06 >= 25, CH06 <= 50)
dim(eph_gmza_ocupados)
```

-   CH06 es la variable que representa la edad en la EPH.
-   Se seleccionan solo las filas donde CH06 \> 30 (personas mayores de
    30 a√±os).
-   ¬øEstar√≠a copado verlo en tablas no? wait for it

# **Ejemplo 2 Filtrar con m√∫ltiples condiciones (AND &)**

```{r filter2}
#Gran San Juan
eph_gsj_ocupadosalto <- eph_data %>%
  filter(AGLOMERADO == 27, ESTADO == 1, CH06 >= 30 & P21 > 40000) 
dim(eph_gsj_ocupadosalto)

#Gran Mendoza
eph_gmza_ocupadosalto <- eph_data %>%
  filter(AGLOMERADO == 10, ESTADO == 1, CH06 >= 30& P21 > 40000)
dim(eph_gmza_ocupadosalto)
```

-   AGLOMREADO 27 y 10 (GSJ y Mendoza respectivamente)
-   ESTADO ==1 (Corresponde a ocupados)
-   CH06 \>= 30 (personas mayores de 30 a√±os)
-   P21 \> 40000 (Ingresos mayores a 40k)
-   No muestro tablas pues no conocemos las funciones!

# **Ejemplo 3: Filtrar con m√∫ltiples condiciones (OR \|)**

```{r filter3}
#Gran San Juan
eph_gsj_ocupadosaltor <- eph_data %>%
  filter(AGLOMERADO == 27, ESTADO == 1, CH06 >= 30 | P21 > 40000) 
dim(eph_gsj_ocupadosaltor)

#Gran Mendoza
eph_gmza_ocupadosaltor <- eph_data %>%
  filter(AGLOMERADO == 10, ESTADO == 1, CH06 >= 30 | P21 > 40000)
dim(eph_gmza_ocupadosaltor)
```

-   Aca el filtro es para pesonas mayores a 30 o que perciban m√°s de 40k

# **Ejemplo 4: Filtrar valores espec√≠ficos con %in%**

```{r filter4}
#Gran San Juan
eph_gsj_ocupadosaltorin <- eph_data %>%
  filter(AGLOMERADO == 27, ESTADO %in% c(1, 2), CH06 >= 30) 
dim(eph_gsj_ocupadosaltorin)

#Gran Mendoza
eph_gmza_ocupadosaltorin <- eph_data %>%
  filter(AGLOMERADO == 10, ESTADO %in% c(1, 2), CH06 >= 30)
dim(eph_gmza_ocupadosaltorin)
```

-   En este caso se seleccionan personas ocupadas o desocupadas mayores
    a 30 a√±os, comando ideal, por ejemplo, para calcular la PEA

# **`select()`: Selecci√≥n de columnas en un dataframe**

La funci√≥n **`select()`** en `dplyr` se usa para **elegir columnas
espec√≠ficas** de un dataframe. Es √∫til para **reducir la cantidad de
variables** y enfocarse en las m√°s relevantes para el an√°lisis.

## **Caracter√≠sticas clave**

-   Permite **seleccionar columnas** por su nombre.
-   Se pueden **excluir columnas** usando `-` antes del nombre.
-   Se pueden usar **rangos de columnas** o patrones con
    `starts_with()`, `ends_with()`, `contains()`.
-   No modifica los datos, solo selecciona variables relevantes.

## **Ejemplos pr√°cticos con el paquete `EPH`**

# **Ejemplo 1. Seleccionar columnas espec√≠ficas**

```{r select1}
eph_reducida <- eph_data %>%
  select(CH04, CH06, P47T, PP3E_TOT) %>%
  rename(
    sexo = CH04,
    edad = CH06,
    ingreso_total = P47T,
    horas_trabajadas = PP3E_TOT
  )
head(eph_reducida)
```

Se seleccionan las variables: - **CH03**: Relaci√≥n de parentesco con
jefe/a de hogar\
- **CH04**: Sexo\
- **CH06**: Edad\
- **CAT_OCUP**: Categor√≠a ocupacional\
- **P21**: Ingreso total individual

# **Ejemplo 2. Excluir columnas espec√≠ficas**

```{r select2}
eph_dataS <- select(eph_data, -P47T)
dim(eph_data)
dim(eph_dataS)
```

Eliminamos P47T porque nos cae mal

# **Ejemplo 3 Seleccionar un rango de columnas**

```{r select3}
eph_rango <- select(eph_data, CH04:CH06)
head(eph_rango)
```

Seleccionamos variables desde CH04 (edad) hasta CH06 (sexo)

# **Ejemplo 4 Seleccionar columnas que empiezan con un prefijo**

```{r select4}
eph_ch <- select(eph_data, starts_with("CH"))
head(eph_ch)
```

Se seleccionan todas las columnas cuyos nombres comienzan con "CH"
(variables de caracter√≠sticas del hogar).

# **Ejemplo 5 Seleccionar columnas que contienen una palabra clave**

```{r select5}
eph_ocup <- select(eph_data, contains("COD"))
head(eph_ocup)
```

Se seleccionan todas las columnas que contienen "COD", por ejemplo
PP04B_COD que muestra c√≥digo ocupacional donde cada caracter implica una
caracter√≠stica de la ocupaci√≥n

# **Ejemplo 6: Renombrar columnas al seleccionarlas**

```{r select6}
eph_ren <- select(eph_data, edad= CH06, sexo = CH04)
head(eph_ren)
```

Ahora las columnas tienen nombres m√°s descriptivos:

-   **CH06** ‚Üí `edad`\
-   **CH04** ‚Üí `sexo`\
-   **P21** ‚Üí `ingresos`

# **`mutate()`: Crear y modificar columnas en un dataframe**

La funci√≥n **`mutate()`** en `dplyr` permite **crear nuevas variables**
o **modificar las existentes** en un dataframe. Es una herramienta clave
para transformar datos en la **Encuesta Permanente de Hogares (EPH)**.

## **Caracter√≠sticas clave**

-   Crea **nuevas columnas** basadas en c√°lculos o condiciones.
-   Modifica **variables existentes** sin necesidad de crear un nuevo
    dataframe.
-   Permite usar **funciones matem√°ticas y l√≥gicas** para transformar
    datos.
-   Compatible con **`group_by()`** para realizar c√°lculos dentro de
    grupos.

## üìä \*\*Ejemplos pr√°cticos con el paquete `EPH`

# **Ejemplo 1: Crear una nueva variable de ingresos anuales**

```{r mutate1}
eph_data <- eph_data %>%
  mutate(ingreso_anual = P47T * 12)
head(select(eph_data, P21, ingreso_anual))
```

Se crea la variable ingreso_anual, multiplicando el ingreso mensual
(P21) por 12.

# **Ejemplo 2: Crear variable categ√≥rica de edad**

```{r mutate2}
# Crear una nueva columna que clasifica a las personas en j√≥venes y adultos

eph_data <- mutate(eph_data, grupo_edad = ifelse(CH06 < 30, "Joven", "Adulto"))
head(select(eph_data, CH06, grupo_edad))
```

Se genera la variable grupo_edad, asignando "Joven" a personas menores
de 30 a√±os y "Adulto" al resto.

# **Ejemplo 3: Modificar una variable existente (transformar ingresos a miles de pesos)**

```{r mutate3}
# Crear una nueva columna que clasifica a las personas en j√≥venes y adultos

eph_data <- mutate(eph_data, P21=P21/1000)
head(select(eph_data, P21))
```

Se transforma P21 para que el ingreso quede expresado en miles de pesos.

# **Ejemplo 4: Calcular el ingreso per c√°pita del hogar**

```{r mutate4}
# Crear una variable de ingreso per c√°pita dividiendo el ingreso total del hogar por la cantidad de miembros

eph_data <- mutate(eph_data, ingreso_per_ocupacion = (ITF / PP03D))

head(select(eph_data, ITF, PP03D, ingreso_per_ocupacion))
```

Se transforma P21 para que el ingreso quede dividido por la cantidad de
ocupaciones.

# **Ejemplo 5: Crear una nueva variable con case_when()**

```{r mutate5}
# Crear una variable de categor√≠a socioecon√≥mica en base al ingreso
eph_data <- mutate(eph_data, categoria_ingreso = case_when(
  P21 < 50000 ~ "Bajo",
  P21 >= 50000 & P21 < 150000 ~ "Medio",
  P21 >= 150000 ~ "Alto"
))

head(select(eph_data, P21, categoria_ingreso))
```

Se usa `case_when()` para asignar categor√≠as de ingreso: - **Menos de
50,000** ‚Üí `"Bajo"`\
- **Entre 50,000 y 150,000** ‚Üí `"Medio"`\
- **M√°s de 150,000** ‚Üí `"Alto"`

# **`arrange()`: Ordenar filas en un dataframe**

La funci√≥n **`arrange()`** en `dplyr` permite **ordenar un dataframe**
en funci√≥n de una o varias columnas.\
Es especialmente √∫til en el an√°lisis de la **Encuesta Permanente de
Hogares (EPH)** para visualizar los datos en orden creciente o
decreciente.

## **Caracter√≠sticas clave**

-   Ordena los datos **en orden ascendente** por defecto.
-   Para **orden descendente**, se usa `desc()`.
-   Se pueden ordenar los datos por **m√∫ltiples columnas**.
-   Compatible con **`group_by()`** para ordenar dentro de grupos.

## **Ejemplos pr√°cticos con el paquete `EPH`**

# **Ejemplo 1: Ordenar por edad en orden ascendente**

```{r arrange1}
# Ordenar las filas seg√∫n la edad en orden ascendente
eph_data <- arrange(eph_data, CH06)

# Ver las primeras filas
head(select(eph_data, CH03, CH04, CH06))
```

Se ordena el dataframe por la variable CH06 (edad) en orden creciente.

# **Ejemplo 2: Ordenar por ingresos en orden descendente**

```{r arrange2}
# Ordenar las filas seg√∫n la edad en orden ascendente
eph_datao <- arrange(eph_data, desc(CH06))

# Ver las primeras filas
head(select(eph_datao, CH03, CH04, CH06))
```

Se ordena el dataframe por la variable CH06 (edad); desc(CH06) de mayor
a menor.

# **Ejemplo 4: ordenar por categor√≠a ocupacional y dentro de cada categor√≠a por ingresos**

```{r arrange3}
# Ordenar las filas seg√∫n la edad en orden ascendente
eph_dataord <- arrange(eph_data, CAT_OCUP, desc(P21))

# Ver las primeras filas
head(select(eph_dataord, CH03, CH04, CH06))

```

Se ordena el dataframe por la variable CH06 (edad); desc(CH06) de mayor
a menor.

# **`group_by()`: Agrupar datos en un dataframe**

La funci√≥n **`group_by()`** en `dplyr` permite **agrupar filas seg√∫n una
o varias variables**, facilitando el c√°lculo de estad√≠sticas dentro de
cada grupo.\
Es clave para segmentar datos en la **Encuesta Permanente de Hogares
(EPH)** y analizar diferentes categor√≠as poblacionales.

## **Caracter√≠sticas clave**

-   Agrupa los datos **sin modificarlos** directamente.
-   Se usa en combinaci√≥n con **`summarise()`** para calcular
    estad√≠sticas dentro de cada grupo.
-   Se pueden agrupar los datos por **una o m√°s variables**.
-   Compatible con otras funciones de `dplyr`, como `mutate()` y
    `arrange()`.

# **Ejemplo 1: Agrupar por g√©nero y calcular el salario promedio**

```{r groupby1}
data_gen <- eph_data %>%
  group_by(CH04) %>%
  summarise(salario_promedio = mean(P21, na.rm = TRUE))

# Ver resultado
print(data_gen)
```

# **Ejemplo 2: Agrupar por g√©nero y contar cu√°ntas personas hay en cada grupo**

```{r groupby2}
data_genc <- eph_data %>%
  group_by(CH04) %>%
  summarise(cantidad = n())

# Ver resultado
print(data_genc)
```

Contamos cu√°ntas personas hay en cada categor√≠a (1 = var√≥n, 2 = mujer).

# **Ejemplo 3: Agrupar por regi√≥n y calcular el ingreso per c√°pita promedio**

```{r groupby3}
data_reg <- eph_data %>%
  group_by(AGLOMERADO) %>%
  summarise(promedio_IPCF = mean(IPCF, na.rm = TRUE))

# Ver resultado
print(data_reg)
```

Contamos cu√°ntas personas hay en cada categor√≠a (1 = var√≥n, 2 = mujer).

# **Ejemplo 3: Agrupar por regi√≥n y calcular el ingreso per c√°pita promedio**

```{r groupby4}
data_reg <- eph_data %>%
  group_by(AGLOMERADO) %>%
  summarise(promedio_IPCF = mean(IPCF, na.rm = TRUE))

# Ver resultado
print(data_reg)
```

Se cuenta cu√°ntas personas hay en cada categor√≠a (1 = var√≥n, 2 = mujer).

# **`summarise()`: Calcular estad√≠sticas por grupo en un dataframe**

La funci√≥n **`summarise()`** en `dplyr` permite **resumir datos**
calculando estad√≠sticas dentro de cada grupo definido con `group_by()`.\
Es esencial para obtener promedios, medianas, sumas y otros indicadores
clave en la **Encuesta Permanente de Hogares (EPH)**.

## **Caracter√≠sticas clave**

-   Se usa con **`group_by()`** para calcular estad√≠sticas por grupo.
-   Puede generar **varias estad√≠sticas en una misma operaci√≥n**.
-   Se pueden usar funciones como **`mean()`**, **`median()`**,
    **`sum()`**, **`min()`**, **`max()`**, entre otras.
-   Permite incluir m√∫ltiples variables resumen.

## **Ejemplos pr√°cticos con el paquete `EPH`**

# **Ejemplo 1: Calcular el salario promedio por categor√≠a ocupacional**

```{r sum1}
data_summarise <- eph_data %>%
  group_by(CAT_OCUP) %>%
  summarise(salario_promedio = mean(P21, na.rm = TRUE))

# Ver resultado
print(data_summarise)
```

Se agrupan los datos seg√∫n categor√≠a ocupacional (CAT_OCUP) y se calcula
el salario promedio (P21).

# **Ejemplo 2: Calcular la mediana de ingresos y el tama√±o de cada grupo**

```{r sum2}
# Aca vamos a agregar otras cositas porque los ejemplos estan muy chotos.
## 1. Excluir valores perdidos y categor√≠as espec√≠ficas
data_filtered <- eph_data %>%
  filter(!is.na(P21), #Sacamos los datos perdidos (is.na)
         CAT_OCUP %in% c(1, 2, 3)) #Les decimos que nos quedamos solo con los valores 1, 2 y 3 de cat_ocup

# Calcular la mediana de ingresos y el total de personas ponderado por FACTOR_EXP

data_summarise <- data_filtered %>%
  group_by(CAT_OCUP) %>%
  summarise(
    mediana_ingreso = median(rep(P21, PONDIIO), na.rm = TRUE),
    total_personas = sum(PONDIIO, na.rm = TRUE)
  ) %>%
  mutate(CAT_OCUP = recode(CAT_OCUP, `1` = "Patron", `2` = "Cuentapropia", `3` = "Obrero"))

# Ver resultado
print(data_summarise)
```

Se agrupan los datos seg√∫n categor√≠a ocupacional (CAT_OCUP) y se calcula
el salario promedio (P21).

# **Ejemplo 3: Calcular el ingreso promedio y la edad media por aglomerado**

```{r sum3}
# Calcular el ingreso y la edad promedio por aglomerado
data_summarise <- eph_data %>%
  group_by(AGLOMERADO) %>%
  summarise(
    ingreso_promedio = mean(P21, na.rm = TRUE),
    edad_promedio = mean(CH06, na.rm = TRUE)
  )

# Ver resultado
print(data_summarise)
```

Se calcula el ingreso promedio (P21) y la edad promedio (CH06) en cada
aglomerado (AGLOMERADO).

# **Ejemplo 4: Calcular el porcentaje de asalariados registrados y no registrados**

```{r sum4}
# Calcular la proporci√≥n de asalariados registrados y no registrados
mt1 <- eph_data %>% 
  filter(AGLOMERADO == 27) %>% 
  summarise(
    pob           = sum(PONDERA),
    PEA           = sum(PONDERA[ESTADO %in% c(1, 2)]),
    ocup          = sum(PONDERA[ESTADO == 1]),
    desocup       = sum(PONDERA[ESTADO == 2]))%>% 
  data.frame() %>% 
  setNames(c("Poblacion Total", "PEA", "Poblaci√≥n Ocupada", "Poblaci√≥n Desocupada")) %>% 
  gather(key = "Variable", value = "Valor")

print(mt1)
```

Se calcula la cantidad de poblaci√≥n total, poblaci√≥n econ√≥micamente
activa, poblaci√≥n ocupada y desocupada en el aglomerado 27 a partir de
la variable ESTADO.

# **`count()`: Contar observaciones en un grupo**

La funci√≥n **`count()`** en `dplyr` permite **contar el n√∫mero de
filas** en cada grupo de una variable.\
Es √∫til para conocer la distribuci√≥n de categor√≠as en la **Encuesta
Permanente de Hogares (EPH)**.

## **Caracter√≠sticas clave**

-   Cuenta la cantidad de filas dentro de cada categor√≠a de una
    variable.
-   Puede utilizarse con **`sort = TRUE`** para ordenar los resultados
    de mayor a menor.
-   Puede combinarse con **`group_by()`** y **`summarise()`** para mayor
    flexibilidad.

# **Ejemplo 1: Contar la cantidad de personas por categor√≠a ocupacional**

```{r count1}
conteo_ocupacional <- eph_data %>% count(CAT_OCUP)
print(conteo_ocupacional)
```

-   Se cuenta la cantidad de personas en cada categor√≠a ocupacional
    (CAT_OCUP).
-   Se usa sort = TRUE para ordenar los resultados de mayor a menor.

# **`rename()`: Cambiar el nombre de columnas en un dataframe**

La funci√≥n **`rename()`** en `dplyr` permite **cambiar el nombre de una
o varias columnas** en un dataframe.\
Es √∫til para hacer que los nombres de las variables sean m√°s claros en
la **EPH**.

## Caracter√≠sticas clave

-   Permite renombrar una o varias columnas al mismo tiempo.
-   Mantiene todas las columnas del dataframe sin eliminarlas ni
    modificarlas.
-   Se usa con la sintaxis `rename(nuevo_nombre = nombre_original)`.

# **Ejemplo 1: Renombrar variables en la EPH**

```{r filter-summarise1}
data_renamed <- eph_data %>%
  rename(
    edad = CH06,
    sexo = CH04,
    ingreso_total = P21
  )

head(data_renamed)
```

#Para cerrar esta parte. Vamos con las funciones que quedan, que no
usamos mucho pero est√°n ah√≠

# **`distinct()`: Eliminar duplicados**

Elimina filas duplicadas basadas en una o varias columnas.

```{r disct}
# Eliminar duplicados en la combinaci√≥n de sexo y edad
eph_data_distinct <- eph_data %>%
  distinct(CH04, CH06, .keep_all = TRUE)

head(eph_data_distinct)
```

Se eliminan registros duplicados con la misma combinaci√≥n de sexo (CH04)
y edad (CH06), manteniendo las dem√°s columnas.

# **`slice()`: Seleccionar filas por posici√≥n**

Extrae filas espec√≠ficas del dataframe seg√∫n su posici√≥n.

```{r slice2}
eph_data_slice <- eph_data %>%
  slice(1:10)

head(eph_data_slice)
```

Extrae las primeras 10 filas del dataframe.

# **`pull()`: Extraer una columna como vector**

Devuelve una √∫nica columna en formato vector, √∫til para c√°lculos o
gr√°ficos.

```{r pull3}
ingresos_vector <- eph_data %>%
  pull(P21)

head(ingresos_vector)
```

Extrae la columna P21 (ingreso total individual) como vector.

# **`relocate()`: Reordenar columnas**

Cambia la posici√≥n de columnas dentro del dataframe.

```{r relco4}
# Mover la columna de ingresos al inicio
eph_data_relocate <- eph_data %>%
  relocate(P21, .before = everything())

head(eph_data_relocate)
```

Mueve P21 (ingreso total individual) al inicio del dataframe.

# **`transmute()`: Crear nuevas columnas y eliminar las originales**

Cambia la posici√≥n de columnas dentro del dataframe.

```{r trans5}
# Crear ingreso anual y eliminar P21
eph_data_transmute <- eph_data %>%
  transmute(ingreso_anual = P21 * 12)

head(eph_data_transmute)
```

Se crea ingreso_anual (multiplicando P21 por 12) y se elimina P21.

# **Ejercicio Integrador**

Supongamos que queremos:

1.  Filtrar personas ocupadas en Gran San Juan mayores de 25 a√±os.
2.  Seleccionar variables clave y calcular el ingreso por hora.
3.  Agrupar por sexo y calcular el promedio y mediana de ingreso.
4.  Ordenar el resultado por promedio de ingreso.

```{r ejercicio-integrador6}
resumen_final <- eph_data %>%
  filter(AGLOMERADO == 27, ESTADO == 1, CH06 > 25) %>%
  select(CH04, CH06, P47T, PP3E_TOT) %>%
  rename(
    sexo = CH04,
    edad = CH06,
    ingreso_total = P47T,
    horas_trabajadas = PP3E_TOT
  ) %>%
  mutate(ingreso_hora = ingreso_total / horas_trabajadas) %>%
  group_by(sexo) %>%
  summarise(
    promedio_ingreso = mean(ingreso_total, na.rm = TRUE),
    mediana_ingreso = median(ingreso_total, na.rm = TRUE)
  ) %>%
  arrange(desc(promedio_ingreso))

print(resumen_final)
```

# Entonces dplyr

El paquete **dplyr** simplifica la manipulaci√≥n de datos en **R**,
especialmente cuando trabajamos con bases complejas como la **EPH**.
Utilizando funciones como `filter()`, `select()`, `mutate()`,
`group_by()`, y `summarise()`, podemos realizar an√°lisis avanzados de
manera eficiente y legible.

# Volvemos a los paquetes incluidos en `{tidyverse}`

Si ustedes instalan tidyverse entonces no tienen que estar instalando
todos estos paquetes uno por uno.

| **Paquete**   | **Funcionalidad principal**            | **Funciones clave**                                                          |
|------------------|--------------------------|-----------------------------|
| **dplyr**     | Manipulaci√≥n y transformaci√≥n de datos | `filter()`, `select()`, `mutate()`, `group_by()`, `summarise()`, `arrange()` |
| **tidyr**     | Organizaci√≥n y estructuraci√≥n de datos | `pivot_longer()`, `pivot_wider()`, `separate()`, `unite()`                   |
| **readr**     | Importaci√≥n de archivos                | `read_csv()`, `read_delim()`, `write_csv()`                                  |
| **purrr**     | Programaci√≥n funcional y listas        | `map()`, `map_df()`, `map_chr()`                                             |
| **tibble**    | Tablas mejoradas en R                  | `as_tibble()`, `tibble()`                                                    |
| **stringr**   | Manipulaci√≥n de texto y caracteres     | `str_detect()`, `str_replace()`, `str_to_lower()`                            |
| **forcats**   | Manejo avanzado de factores            | `fct_reorder()`, `fct_lump()`, `fct_relevel()`                               |
| **lubridate** | Manipulaci√≥n de fechas y tiempos       | `ymd()`, `mdy()`, `hms()`, `floor_date()`                                    |

En este taller, utilizaremos tidyverse en combinaci√≥n con el paquete eph
para analizar bases de la Encuesta Permanente de Hogares (EPH), lo que
nos permitir√° realizar transformaciones, c√°lculos y res√∫menes sobre
variables clave del mercado de trabajo.

# `tidyr`: Organizaci√≥n y estructuraci√≥n de datos

El paquete `tidyr` forma parte del ecosistema `tidyverse` y se centra en
la transformaci√≥n de datos para que sean **ordenados** ("tidy"). Esto
implica estructurar los datos de modo que cada columna represente una
variable, cada fila una observaci√≥n y cada celda un valor.

## Caracter√≠sticas principales de `tidyr`

1.  **Transformaci√≥n de datos a formato ordenado ("tidy data")**
    -   Cada columna representa una variable.\
    -   Cada fila es una observaci√≥n.\
    -   Cada celda contiene un solo valor.
2.  **Facilidad para convertir entre formatos ancho y largo**
    -   Usa `pivot_longer()` para transformar datos de **formato ancho**
        a **largo**.\
    -   Usa `pivot_wider()` para transformar datos de **formato largo**
        a **ancho**.
3.  **Herramientas para manejar y limpiar datos**
    -   `drop_na()`: Elimina filas con valores faltantes.\
    -   `fill()`: Rellena valores `NA` con el dato m√°s cercano.\
    -   `replace_na()`: Reemplaza valores faltantes con un valor
        espec√≠fico.
4.  **Separaci√≥n y combinaci√≥n de columnas**
    -   `separate()`: Divide una columna en m√∫ltiples columnas usando un
        separador.\
    -   `unite()`: Une varias columnas en una sola con un delimitador
        personalizado.
5.  **Compatibilidad con el ecosistema `tidyverse`**
    -   Funciona de manera fluida con `dplyr`, `ggplot2`, `readr` y
        otros paquetes de `tidyverse`.\
    -   Usa sintaxis basada en tuber√≠as (`%>%` o `|>`).
6.  **Mejora la eficiencia en la manipulaci√≥n de datos**
    -   Permite realizar transformaciones con menos c√≥digo y de forma
        m√°s legible.\
    -   Optimiza la manipulaci√≥n de bases de datos grandes en R.

## Vamos con los ejemplos

# **Ejemplo 1: `pivot_longer()` - Convertir columnas en filas**

Esta funci√≥n **transforma datos de formato ancho a formato largo**, √∫til
para normalizar bases de datos.

```{r p134}
# Crear ingreso anual y eliminar P21
tabla_lon1 <- eph_data %>% 
  summarise(pob                 = sum(PONDERA),
            ocup                  = sum(PONDERA[ESTADO == 1]),
            desocup               = sum(PONDERA[ESTADO == 2]),
            PEA                       = ocup + desocup,
            'Tasa de Actividad'               = round(PEA/pob *100, 1),
            'Tasa de Empleo'                  = round(ocup/pob *100, 1),
            'Tasa de Desocupaci√≥n'            = round(desocup/PEA *100, 1))

print (tabla_lon1)

```

Inleible, no?

```{r p1}
tabla_lon2 <- eph_data %>% 
  summarise(pob                 = sum(PONDERA),
            ocup                  = sum(PONDERA[ESTADO == 1]),
            desocup               = sum(PONDERA[ESTADO == 2]),
            PEA                       = ocup + desocup,
            'Tasa de Actividad'               = round(PEA/pob *100, 1),
            'Tasa de Empleo'                  = round(ocup/pob *100, 1),
            'Tasa de Desocupaci√≥n'            = round(desocup/PEA *100, 1))%>%
  pivot_longer(cols = c(5:7), names_to = "Variable", values_to = "Valor") %>%
  group_by(Variable) %>%
  summarise(Valor = first(Valor))

print (tabla_lon2)

```

Ahora si

# **Ejemplo 2: `pivot_wider()` - Convertir columnas en filas**

Convierte datos de formato largo a formato ancho, √∫til para
visualizaci√≥n y an√°lisis. Volvemos con la tabla que hicimos reci√©n para
ver como cambia

```{r p22}
tabla_wid <- tabla_lon2 %>% 
  pivot_wider(names_from = "Variable", values_from = "Valor")

print(tabla_wid)
```

Sirve, por ejemplo, para hacer una tabla donde cada fila sea un
trimestre

# **Ejemplo 3: `separate()` - Dividir una columna en varias**

Descompone una columna en varias nuevas seg√∫n un separador.

```{r p2}
data_sep1 <- tibble(nombre_completo = c("John_Garc√≠a", "Kyuss_Kapo"))

print(data_sep1)

data_sep <- separate(data_sep1, nombre_completo, into = c("nombre", "apellido"), sep = "_")

print(data_sep)
```

# **Ejemplo 4: `unite()`: Unir varias columnas en una sola**

Hace la operaci√≥n inversa de `separate()`.

```{r p2342}
data_unite <- unite(data_sep, "nombre_completo", nombre, apellido, sep = "_")

print(data_unite)
```

# **Ejemplo 5: `drop_na()`: Eliminar valores faltantes**

Filtra las filas que contienen valores faltantes en una o m√°s columnas.

```{r p543}
data_na <- tibble(Vacas = 1:3, Terneritos = c(10, NA, 30))
print(data_na)
data_clean <- drop_na(data_na)
print(data_clean)
```

# **Ejemplo 6: `fill()`: Rellenar valores faltantes con el m√°s cercano**

Rellena los valores `NA` con el valor no faltante m√°s cercano hacia
arriba o abajo.

```{r p4342}
data_fill1 <- tibble(Guitarristas = c("Dimebag Darrel", "Tano Marciello", "Jaime P√°gina", "Vladimir Lenin"), Guitarras = c(5, NA, 3, NA))
print(data_fill1)

data_fill2 <- fill(data_fill1, Guitarras, .direction = "down")
print(data_fill2)
```

¬øY como fillea la cuesti√≥n ac√°? los valores faltantes en grupo fueron
rellenados con el valor inmediatamente anterior.

# Conclusi√≥n

El paquete `tidyr` proporciona funciones esenciales para estructurar
bases de datos de manera ordenada y optimizar su an√°lisis en el
ecosistema `tidyverse`. Su uso facilita la manipulaci√≥n de datos en
proyectos de investigaci√≥n y an√°lisis de datos socioecon√≥micos.

# **`readr`**: Organizaci√≥n y estructuraci√≥n de datos

El paquete **`readr`** del `tidyverse` se usa para **importar y exportar
datos** en diversos formatos como CSV, TSV y archivos de texto plano. Es
una alternativa r√°pida y eficiente en comparaci√≥n con las funciones base
de R (`read.csv`, `read.table`).

## **Caracter√≠sticas clave**

-   Lectura r√°pida de archivos CSV, TSV y de texto plano.
-   Soporta codificaciones y delimitadores personalizados.
-   Convierte autom√°ticamente los tipos de datos.
-   Compatible con `tibble` para facilitar la manipulaci√≥n de datos.

### **Ejemplos pr√°cticos con la base `eph_data`**

# **Ejemplo 1: Importar datos desde un CSV**

```{r readr1}
# Cargar el paquete
library(readr)

# Importar datos de CBA desde un archivo CSV
CBA_Regional <- read_csv("CBA Region.csv")

# Mostrar las primeras filas
head(CBA_Regional)
```

-   `read_csv()` carga un archivo CSV y lo convierte en un `tibble`.
-   Identifica autom√°ticamente los tipos de datos de cada columna.

# **Ejemplo 2: Exportar datos a un archivo CSV**

```{r readr2}
# Guardar un subconjunto de datos en un nuevo archivo CSV
write_csv(CBA_Regional, "cba_cuyo.csv")
```

-   `write_csv()` exporta los datos en un formato limpio y sin comillas
    innecesarias.
-   Es ideal para compartir datasets procesados.

# **`tibble`**: Organizaci√≥n y estructuraci√≥n de datos

El paquete **`tibble`** de `tidyverse` es una alternativa moderna a los
`data.frame` base de R. Mejora la organizaci√≥n y presentaci√≥n de datos,
facilitando su manipulaci√≥n y an√°lisis.

## **Caracter√≠sticas clave**

-   Imprime datos de forma m√°s **legible** y compacta.
-   **No convierte** autom√°ticamente caracteres en factores.
-   Permite definir **nombres de columnas sin restricciones**.
-   Compatible con **dplyr y otros paquetes del `tidyverse`**.

### **Ejemplos pr√°cticos con la base `eph_data`**

# **Ejemplo 1: Convertir un data.frame en tibble**

```{r tibble1}
# Cargar el paquete
library(tibble)

# Convertir eph_data en un tibble
eph_tibble <- as_tibble(eph_data)

# Ver la estructura
eph_tibble
```

-   `as_tibble()` convierte un `data.frame` en un `tibble`.
-   La impresi√≥n es m√°s limpia y muestra solo las primeras filas.

# **Ejemplo 2: Crear un tibble desde cero**

```{r tibble2}
# Crear un tibble manualmente
datos_manual <- tibble(
  ID = c(1, 2, 3),
  Nombre = c("Juan", "Mar√≠a", "Luis"),
  Edad = c(25, 30, 40)
)

# Mostrar el tibble
datos_manual
```

-   `tibble()` permite crear tablas de datos directamente.
-   No fuerza la conversi√≥n de tipos de datos.

# **Ejemplo 3: Seleccionar columnas y filas**

```{r tibble3}
# Filtrar y seleccionar columnas
eph_filtrado <- eph_tibble %>% 
  select(CODUSU, CH06, P21) %>%  # Seleccionar columnas
  filter(CH06 >= 30)              # Filtrar por edad

eph_filtrado
```

-   Compatible con `dplyr` para manipular datos de forma eficiente.
-   `select()` elige columnas espec√≠ficas.
-   `filter()` aplica condiciones de filtrado.

# **Ejemplo 4: Acceder a columnas con `pull()`**

```{r tibble4}
# Extraer una columna como vector
edades <- eph_tibble %>% pull(CH06)

# Ver las primeras edades
head(edades)
```

-   `pull()` extrae una columna de un tibble como vector.
-   √ötil para c√°lculos y visualizaciones r√°pidas.

## **Conclusi√≥n**

El paquete `tibble` mejora la presentaci√≥n y manipulaci√≥n de datos en R,
optimizando su integraci√≥n con `dplyr` y el ecosistema `tidyverse`. Su
uso es clave para trabajar con bases de datos como `eph_data` de manera
m√°s eficiente y clara.

# **`stringr`**: Organizaci√≥n y estructuraci√≥n de datos

El paquete **`stringr`** de `tidyverse` facilita la manipulaci√≥n de
cadenas de texto en R. Proporciona funciones intuitivas, optimizadas y
compatibles con `tidyverse` para trabajar con datos textuales de manera
eficiente.

## **Caracter√≠sticas clave**

-   Funciones consistentes con prefijo `str_`.
-   Uso de expresiones regulares para b√∫squeda y reemplazo.
-   Manejo de caracteres especiales y tildes.
-   Compatible con `tidyverse` y `dplyr`.

### **Ejemplos pr√°cticos con la base `eph_data`**

# **Ejemplo 1: Convertir texto a min√∫sculas o may√∫sculas**

```{r stringr1}
# Cargar el paquete
library(stringr)

#Vemos como est√° ahora
head(eph_data$categoria_ingreso)

#Los ponemos en mayusculas
eph_datagh <- eph_data %>% 
  mutate(categoria_ingreso = str_to_upper(categoria_ingreso))

#Revisamos
head(eph_datagh$categoria_ingreso)
```

-   `str_to_lower()` convierte texto a min√∫sculas.
-   `str_to_upper()` convierte a may√∫sculas.

# **Ejemplo 2: Extraer parte de una cadena**

```{r stringr2}
# Extraer los primeros 3 caracteres de una variable
eph_datastring <- eph_data %>% 
  mutate(CodigoRecortado = str_sub(CODUSU, 1, 3))

# Ver primeras filas
head(eph_datastring$CodigoRecortado)
```

-   `str_sub()` permite extraer partes de una cadena.
-   √ötil para trabajar con c√≥digos o identificadores.

# **Ejemplo 3: Reemplazar texto en una variable**

```{r stringr3}
# Reemplazar "primario" por "nivel b√°sico"
eph_datax <- eph_data %>% 
  mutate(categoria_ingreso = str_replace(categoria_ingreso, "Bajo", "Ultrabajo"))

# Ver primeras filas
head(eph_datax$categoria_ingreso)
```

-   `str_replace()` sustituye la primera coincidencia.
-   `str_replace_all()` reemplaza todas las coincidencias.

# **Ejemplo 4: Detectar la presencia de un patr√≥n**

```{r stringr4}
# Detectar si la variable NIVEL_ED contiene "universitario"
eph_dataxd <- eph_datax %>% 
  mutate(categoria_ingreso = str_detect(categoria_ingreso, "Ultrabajo"))

# Ver distribuci√≥n de valores
table(eph_dataxd$categoria_ingreso)
```

-   `str_detect()` devuelve `TRUE` si el patr√≥n aparece en el texto.
-   √ötil para clasificar datos textuales.

# **Conclusi√≥n**

El paquete `stringr` permite trabajar de manera eficiente con datos
textuales en R, facilitando la manipulaci√≥n de variables en bases de
datos como `eph_data`. Su integraci√≥n con `tidyverse` lo convierte en
una herramienta fundamental para limpiar y estructurar datos.

# Ahora vamos con la pr√°ctica guiada

## Consignas de ejercicio en grupos de 3 personas y para resolver en 15 minutos

1)  Sobre la tabla de la pracitca guiada anterior, quiero saber cuantas
    personas hasta 29 a√±os hay ocupadas y desocupadas por grupo de edad
    y sexo

#Cosas a tener en cuenta: ##Tienen que armar un mutate de la variable
ESTADO para que quede con los valores de ocupado y desocupado; consulten
el registro de EPH para ver que valores corresponden a cada cosa (para
la base individual)
